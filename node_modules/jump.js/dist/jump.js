(function(global,factory){"object"===typeof exports&&"undefined"!==typeof module?module.exports=factory():"function"===typeof define&&define.amd?define(factory):global.Jump=factory()})(this,function(){'use strict';// Robert Penner's easeInOutQuad
// find the rest of his easing functions here: http://robertpenner.com/easing/
// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js
var easeInOutQuad=function easeInOutQuad(t,b,c,d){t/=d/2;if(1>t)return c/2*t*t+b;t--;return-c/2*(t*(t-2)-1)+b},_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},jumper=function jumper(){// private variable cache
// no variables are created during a jump, preventing memory leaks
var element=void 0,start=void 0,stop=void 0,offset=void 0,easing=void 0,a11y=void 0,distance=void 0,duration=void 0,timeStart=void 0,timeElapsed=void 0,next=void 0,callback=void 0;// element to scroll to                   (node)
// to call when done scrolling            (function)
// scroll position helper
function location(){return window.scrollY||window.pageYOffset}// element offset helper
function top(element){return element.getBoundingClientRect().top+start}// rAF loop helper
function loop(timeCurrent){// store time scroll started, if not started already
if(!timeStart){timeStart=timeCurrent}// determine time spent scrolling so far
timeElapsed=timeCurrent-timeStart;// calculate next scroll position
next=easing(timeElapsed,start,distance,duration);// scroll to it
window.scrollTo(0,next);// check progress
timeElapsed<duration?window.requestAnimationFrame(loop)// continue scroll loop
:done();// scrolling is done
}// scroll finished helper
function done(){// account for rAF time rounding inaccuracies
window.scrollTo(0,start+distance);// if scrolling to an element, and accessibility is enabled
if(element&&a11y){// add tabindex indicating programmatic focus
element.setAttribute("tabindex","-1");// focus the element
element.focus()}// if it exists, fire the callback
if("function"===typeof callback){callback()}// reset time for next jump
timeStart=!1}// API
function jump(target){var options=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{};// resolve options, or use defaults
duration=options.duration||1e3;offset=options.offset||0;callback=options.callback;// "undefined" is a suitable default, and won't be called
easing=options.easing||easeInOutQuad;a11y=options.a11y||!1;// cache starting position
start=location();// resolve target
switch("undefined"===typeof target?"undefined":_typeof(target)){// scroll from current position
case"number":element=void 0;// no element to scroll to
a11y=!1;// make sure accessibility is off
stop=start+target;break;// scroll to element (node)
// bounding rect is relative to the viewport
case"object":element=target;stop=top(element);break;// scroll to element (selector)
// bounding rect is relative to the viewport
case"string":element=document.querySelector(target);stop=top(element);break;}// resolve scroll distance, accounting for offset
distance=stop-start+offset;// resolve duration
switch(_typeof(options.duration)){// number in ms
case"number":duration=options.duration;break;// function passed the distance of the scroll
case"function":duration=options.duration(distance);break;}// start the loop
window.requestAnimationFrame(loop)}// expose only the jump method
return jump},singleton=jumper();return singleton});